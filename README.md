
## Конспект

| **Сложные типы данных** | Есть два типа переменных Примитивные и Сложные. Сложные начинаются с заглавной буквы. Например, `String`. Сложные типы данных создаются через ключевое слово `new`. <br>Пример: `Scanner scanner = new Scanner(System.in)`. Сложные типы могут хранить значения и выполнять определенные действия. Тип `String` исключение - можно объявлять без new<br>Примитивные типы всегда доступны в программе. Импортировать нужны только сложные типы.<br> |
| ----------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Пакеты в Java**       | Scanner находится в `java.utils`<br>Пример импорта в java:<br>`import java.utils.Scanner`<br><br>Пакеты могут делиться на подпакеты. `java` -> `java.utils`<br><br>                                                                                                                                                                                                                                                                                |
| **Объекты в java**      | Объекты могут выполнять действия. У каждого объекта есть методы. Методы вызываются через точку. `Scanner` нужен для считывания информации ввода в консоли. Для считывания целого числа `nextInt()`, `nextDouble()` - для дробного, `nextLine()` - для строки до переноса строки, `next()` - для строки до первого пробела.<br>                                                                                                                     |
| ==Summary==             | Объекты могут выполнять действия и импортируются из пакетов, примитивы всегда доступны без импорта и можно отличить по написанию с маленькой буквы, объявление нового объекта через new, <br>main - точка входа программы, <br>циклы `for` имеют точку старта, условие выхода и шаг `(int i = 0; i > 10; i++)`                                                                                                                                     |

``` text
 /\__/\
( =^.^=)
(  _)_)
```

---

>[!task] Метод `new` выделяет память под новый объект и вызывает конструктор класса, который имеет такое же имя, что и класс. Метод `new` специальный, он ничего не возвращает, даже void. Используется для инициализации объектов


```JAVA

public class Car {
    private String color; // Поле класса, представляющее цвет автомобиля

    // Конструктор класса Car
    public Car(String color) {
        this.color = color; // Инициализация поля color значением, переданным при создании объекта
    }
}

Car myCar = new Car("Red");

```

---

## Конспект

| **Циклы while**                                        | Такой цикл подходит для случаев, когда количество итераций неизвестно. В скобках пишется условие выхода, цикл будет работать, пока значение в скобках ` true` .  Цикл while можно использоваться, когда есть зависимость от внешних данных, которые изначально неизвестны. Рандомизация есть в модуле `java.util.Random` . Если в условии написать ` false `, то будет вызвано исключение ` unreachable statement ` . Остановить цикл можно словом `break` . Переключить на следующую итерацию через слово `continue ` . |
| ------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Практические задачи**                                | Пару простых задач; изменение с бесконечного цикла, но конечный с условием в `while`                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| **Добавляем бесконечный цикл в финансовое приложение** | Исключение (Exception) происходят в процессе работы программы, например, деление на 0 или открытие файла, которого не существует. <br>Важно различать исключение и синтаксическую ошибку.                                                                                                                                                                                                                                                                                                                                |
| ==Summary==                                            | 1. Вложенные циклы используются для выполнения повторяющихся задач с более сложной логикой.<br>2. Цикл while используется, когда число итераций неизвестно и зависит от внешних данных.<br>3. С помощью while можно создать бесконечный цикл, который можно остановить с помощью слова break.<br>4. Циклы используются в большинстве программ и позволяют избежать дублирования кода и описать большое количество действий небольшим фрагментом кода.                                                                    |

---

## Конспект

| **Массивы**                   | Объявление массива `String[] myMass = {'a', 'b', 'c'}`<br>К элементам массива можно обращаться по ключу. Задавать новое значение можно с помощью присваивания и обращения по ключу: `myMass[0] = 'v'`<br>                                                                                                                                                                                                                                                                                                                                                                               |
| ----------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Взаимодействия с массивом** | Для перемещения двух значений между ячейками можно использовать третью переменную `swap/temp `или как-то так                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| **Длинна массива**            | `myMass.length();` Длина массива = количество элементов в нем. Если создается массив без значений его размер указывается вручную. Пример объявления:<br>`String[] myMass = new String[4];` Длина указывается там, где стоит 4, то есть в квадратных скобках. Изменить размер массива после объявления невозможно.<br>Вариант инициализации массива в две строки:<br>`String[] myMass;`<br>`myMass = new String[4];`<br>Элементы массива в этом случае инициализируются нулями.<br><br>Либо с уже известными значениями:<br>`String[] myMass;`<br>`myMass = {'a', 'aa', 'aaa', 'aaaa'};` |
| ==Summary==                   | Массив хранит в себе значения только одного типа: `int`, `double`, `boolean`, `String`. Чтобы указать значения в массиве, использовать `{...}`. Индексация массива начинается с нуля. Тип индекса в массиве всегда `int`, а тип элемента может быть любым.                                                                                                                                                                                                                                                                                                                              |

``` java
public class Main {
	public static void main(String[] args) {
        String str = "Hello";
        boolean contains = str.contains("llo"); // Вхождение подстроки в строке
        System.out.println(contains); // Выведет: true
    }
}
```


| **Массивы и циклы**        | Много повторяющихся строк кода можно объединить в цикл for. Он обычно начинается с нуля и заканчивается на длине массива.                                                                                                     |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Выход за границы цикла** | Если попробовать вызвать элемент массива с несуществующим индексом, то броситься исключение `ArrayIndexOutOfBoundsException`. Ошибка произойдет, если будут вызваны значение меньше нуля и значение больше `length - 1`. <br> |
| ==Summary==                | Используя ключевое слово `new` можно объявить новый массив. Для работы с массивом используют цикл `for`, так как значение элементов в массиве всегда известно.                                                                |

---

## Конспект

| **Арифметические операции** | Операторы всё те же: `+ - * / %`<br>Сокращенный вид: <br>`a += b`<br>`a -= b`<br>`a *= b`<br>`a /= b` <br>`a %= b`<br><br>Если в операндах есть типы с дробной части, то результат тоже будет с дробной частью. Результат типа double нельзя сохранить в переменную типа int. <br>Примеры заданий ниже<br>\    /<br>  \\/ |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Инкремент и декремент**   | i++ и i--  это инкремент и декремент соответственно. Их можно написать как до переменной, так и после. Запись называют "постфиксной" если знак идет после имени переменной, "префиксной" - если идет до. Выбор записи определяет порядок выполнения в коде, префиксные операции всегда выполняются первыми в строке.      |
| **Порядок вычислений**      | 1. Первыми отработают вычисления префиксного инкремента и декремента<br>2. Затем - операторы умножения, деления и остатка от деления<br>3. Третьи - операторы сложения и вычитания<br>4. Последними выполняются операции с постфиксным инкрементом и декрементом                                                          |
|                             |                                                                                                                                                                                                                                                                                                                           |

```java

public static void main(String[] args) {
        double x = 120;
        int y = 50;
        System.out.println(x + y);

        double l = 97.45;
        int m = 15;
        System.out.println(l - m);

        double b = 120.5;
        int c = 43;
        System.out.println(b * c);
    }
```

```console
170.0
82.45
5181.5
```

```java
int a = 24;
double b = a / 5; // Тут будет 4, т.к. работаем с целыми числами
System.out.println(b % 2.5);
```

```console
1.5 // Остаток от деления 4.0 на 2.5 равен 1.5
```

---

## Конспект

| **Логические значение boolean** | True/False. False это отрицание, можно изменить в коде след. образом: `!(2 == 3)`                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| ------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Логическое И**                | `&&`<br>Если одно из выражений ложно, то все выражение будет ложным                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| **Логическое ИЛИ**              | `\|\|`<br>Если хоть одно выражение верно, то все выражение будет верным                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| **Порядок логических операций** | 1. Выполняются отрицания `!`<br>2. Логические умножение `&&`<br>3. Логическое сложение `\|\|`<br><br>Java использует "короткую схему" для логических операций. В примере с "И": `a && b` - если `a` будет ЛОЖЬ, то второе значение проверяться не будет. В случае с "ИЛИ": `a \|\| b` - если `а` будет ИСТИНА, то значение справа также не будет определяться, так как ответ уже очевиден.<br>Также можно использовать длинную схему, где проверяются оба выражения с обеих сторон от логического знака. Выглядит это так:<br>И: `&`<br>ИЛИ: `\|`<br> |

---

## Конспект

| **Оператор switch** | Используется для случая с больших количеством вариантов и условий.<br>Синтаксис:<br> |
| ------------------- | ------------------------------------------------------------------------------------ |


```java
...
	switch (item) {
    case "1": ...
    case "2": ...
    case "3": ...
	}
...
```


---
## Конспект

| **Правила хорошего кода** | Хорошим можно назвать такой код, который легко читается, структурирован и содержит минимум багов. Мы рассмотрим самые распространённые среди новичков ошибки и расскажем, как их избежать.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|                           | **Некорректная работа приложения** — наиболее частая ошибка. Например, программа должна была напечатать элементы списка, а вместо этого выводит только первое значение. Может быть и такое, что из-за багов приложение вовсе не запускается.<br><br>Чтобы сэкономить своё время, следуйте первому правилу: **перед отправкой кода на любую (даже автоматическую) проверку всегда запускайте проект локально.** Убедитесь, что:<br><br>1. Проект корректно и без ошибок компилируется и запускается.<br>2. Все требования реализованы в полном объёме, каждый пункт задания работает корректно. Допустим, по ТЗ вам нужно написать приложение, которое печатает элементы массива, удаляет выбранный элемент и меняет значение выбранного элемента. В вашем коде нужно реализовать все три пункта. При запуске эти опции должны быть доступны пользователю и выполняться так, как было задумано.<br><br>Со временем проверка кода превратится в полезную привычку. Она выручит вас как в учёбе, так и на работе. Просто представьте, как будет неловко в свою первую рабочую неделю отправить коллегам код, который не компилируется!<br><br>Вооружившись этим правилом, вы можете смело двигаться дальше, навстречу заданию! |

>[!tip] Массив, размер которого во время выполнения программы можно изменить называется **динамическим**


## Конспект


| Методы                                  | Набор команд, объявление методов делается с помощью служебных символов:<br>`public / private`<br>Первый доступен из любого другого класса. Второй доступен только внутри своего класса.<br>`static / final`<br>`abstact - interface`<br>После объявления метода его нужно вызвать, точка входа это метод `main`. Методы можно вызывать друг из друга, но цепочка начнется из `main`. <br> |
| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Возвращение значений из метода          | `void` означается, что метод ничего не возвращает. Если надо, чтобы метод возвращал допустим строку, то нужно указать String в возвращаемом значении: `public static String myName()...`<br>                                                                                                                                                                                              |
| `return`                                | Методом return можно останавливать метод, в который он прописан.                                                                                                                                                                                                                                                                                                                          |
| Параметры, аргументы и сигнатура метода | В скобках после имени метода пишутся ПАРАМЕТРЫ функции. Аргументы - конкретные значения параметров. Пример:<br>`public static String sayHello(String name)` - это параметр<br>`sayHello("Boris")` - это аргумент<br>                                                                                                                                                                      |

---

## Конспект


| Метод `main` | Метод `main` всегда объявляется как `static public void`. Если он не будет возвращаться значение другого типа, Java не сможет распознать его как главный метод программы и запустить. У метода `main` единственный параметр - массив строк `String[] args` . Имя `args` общепринято. <br><br>Массив `String[] args` содержит стартовый набор аргументов программы. Они нужны для того, чтобы управлять программой снаружи. <br><br>Метод `return` в `main` остановит выполнение программы.<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| ------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ==Summary==  | Метод — набор команд с понятным именем. С его помощью можно избежать дублирования команд и просто вызывать их в нужном месте одной строкой.<br><br>Объявляют метод так: сначала указывают служебные слова, а затем имя метода с круглыми скобками. Например: `public static void sayHello()`.<br><br>После того как метод объявлен, его нужно реализовать: перечислить в его теле (в фигурных скобках) все относящиеся к нему команды — например, операции с переменными и массивами, условные выражения и циклы.<br><br>Чтобы выполнить метод, сначала его нужно вызвать. Для этого следует указать его имя и круглые скобки. Например: `sayHello()`.<br><br>Если при объявлении метода использовано служебное слово `void`, то такой метод ничего не возвращает. Но вместо `void` можно подставить любой тип возвращаемого значения. Например: `public static String giveMeAnApple()`. Из такого метода можно будет получить результат его работы.<br><br>Получить результат работы метода позволяет оператор `return`. После слова `return` нужно указать возвращаемое значение. Например: `return "Яблоко"`. Тип возвращаемого значения должен соответствовать типу, который указан в объявлении метода, иначе произойдёт ошибка.<br><br>С помощью `return` можно также прервать работу метода — для этого оператор ставят в нужном месте блока кода. А если поставить `return` в блоке бесконечного цикла, он прервёт выполнение и цикла, и метода.<br><br>При объявлении метода в круглых скобках можно указать типы и имена переменных, которые он будет принимать. Это аргументы, или параметры, метода. Сигнатура метода — это его имя вместе с набором его параметров.<br><br>При запуске программы начинает выполняться код, который написан внутри метода `main`. Объявление этого метода начинается со служебных слов `public` и `static`, а перед его именем нужно поставить тип `void`. `main` всегда должен быть `void`, иначе Java не сможет распознать его как главный метод программы и запустить. |


---

## Конспект


| Декомпозиция кода на методы | **Декомпозиция** - это разбиение сложной и непонятной функции на несколько мелких и более понятных по функционалу. При декомпозиции принято придерживаться такого правила: один метод - одна задача<br>Подсказка: "Какую задачу решает этот метод?" - Если в ответе много "И", то следует декомпозировать этот метод. Структурирование кода делает его читабельным и понимаемым. Это увеличивает скорость написания программы и сокращает трудозатраты команды разработчиков.                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|                             | Декомпозиция кода всегда отдельный этап работы. Когда код написан, перечитайте код и в случае необходимости дополнительно декомпозируйте его. Найдя отличный вариант декомпозиции код будет и читабельным, и понятным, что повысит качество работы.<br><br>Порядок **действий при декомпозиции**:<br>1. Сформулируйте, какие задачи должна решать программа. Для каждой задачи нужно предусмотреть свой метод. <br>2. Если какой-то код дублируется, это повод вынести его в отдельный метод<br>3. Проанализируйте, не возвращают ли методы какой-либо результат, работают ли они с внешними значениями. В зависимости от этого предусмотрите возврат значения или добавьте метод в параметры.<br>4. Объявите и реализуйте все нужные методы. Проверьте их имена - они должны быть емкими и лаконичными, понятными другим разработчикам. |
|                             | **Сигнатура метода** - это часть метода, которая включает в себя:<br>- имя метода<br>- количество и типы параметров, которые метод принимает<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| ==Summary==                 | Блоки методов имеют свою область видимости и при написании кода нужно это учитывать. Они требуют объявления для инициализации и использования.<br>Область видимости позволяет использовать одинаковые имена переменных в разных блоках кода. <br>Если методу указать в качестве аргументов переменные, то он сможет их использовать в своем блоке кода.<br>Когда в качестве аргумента используют имя переменной, в метод передается копия её значения. Даже если внутри метода значение будет изменено, то внешняя переменная останется прежней.<br>Декомпозиция, или разделение, - это процесс упрощения кода для понимания, она позволяет сосредоточиться на одной задаче за раз.<br>Золотое правило декомпозиции: один метод - одна задача.<br>                                                                                       |

```java

public class Practicum {

    public static void main(String[] args) {
        String pixelName = "Пиксель"; // Хомяк
        double[] feedExpensesHamster = {100.50, 236.0, 510.6, 150.20, 80.0, 172.0, 135.4};
        sayHello(pixelName);
        double maxFeedExpenseHamster = findMaxExpense(feedExpensesHamster);;
        System.out.println("Твой самый дорогой корм стоил " + maxFeedExpenseHamster);
        double sumFeedHamster = findExpensesSum(feedExpensesHamster);
        System.out.println("Всего на корм было потрачено " + sumFeedHamster);
        sayEnjoyMeal(pixelName);

        String baitName = "Байт"; // Кот
        double[] feedExpensesCat = {70.50, 146.0, 710.6, 250.20, 83.0, 19.0, 55.4};
        sayHello(baitName);
        double maxFeedExpenseCat = findMaxExpense(feedExpensesCat);
        System.out.println("Твой самый дорогой корм стоил " + maxFeedExpenseCat);
        double sumFeedCat = findExpensesSum(feedExpensesCat);
        System.out.println("Всего на корм было потрачено " + sumFeedCat);
        sayEnjoyMeal(baitName);
    }

    public static void sayHello(String name) { // Приветствие
        System.out.println("Привет, "+ name +"!");
    }

    public static void sayEnjoyMeal(String name) { // Пожелание приятного аппетита
        System.out.println("Приятного аппетита, " + name + "!");
    }

    public static double findMaxExpense(double[] expenses) { // Подсчет самого дорогого корма
        double maxFeedExpense = 0;
        for (int i = 0; i < expenses.length; i++) {
            if (expenses[i] > maxFeedExpense) {
                maxFeedExpense = expenses[i];
            }
        }
        return maxFeedExpense;
    }

    public static double findExpensesSum(double[] expenses) { // Подсчет общих трат на корм
        double sumFeed = 0;
        for (int i = 0; i < expenses.length; i++) {
            sumFeed = sumFeed + expenses[i];
        }
        return sumFeed;
    }
}
```

---

## Конспект

| Объекты и классы | Основное предназначение класса - создание структуры объекта. <br>У каждого класса есть *описание*. В фигурных скобках описываются атрибуты объекта и его методы. Чтобы создать объект используют `new`<br>Например, `Hamster bite = new Hamster();` <br>Обращение к методам и атрибутам класса происходит через точку. <br>`System.out.println(bite.age);` <br>                    |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
```java
puclic class Hamster {
	// Реализация класса
	int age = 2;
	String name = 'Byba';
	int weight = 350;
	String color = 'Orange';

	// есть
    void eat(int foodWeight) { 
        weight = weight + foodWeight; 
    } 

    // бегать в колесе
    void runInWheel() {
        System.out.println("Бегу-бегу-бегу!");
        weight = weight - 5;
    }

    // прятать семечки
    void hideSeeds(int seedWeight) { 
        weight = weight + seedWeight; 
        System.out.println("Зимой не заголодаю.");
    }
}
```

```java 
// Объявление в main
 public static void main(String[] args) {
	Hamster bite = new Hamster();
    }
```

---

## Конспект


| Конструктор                        | Позволяет создавать новые объекты класса. Конструктор это метод, который автоматически вызывается при создании нового объекта класса. Если конструкторов нет в классе, то Java автоматически предоставляет конструктор по умолчанию без параметров.<br>                                                                                                                                  |
| ---------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Особенности работы с конструктором | В зависимости от количества параметром Java понимает, какой конструктор надо вызвать. В классе может быть объявлено несколько конструкторов. <br><br>Шаблон для создания объектов, содержит описание полей и методов - Класс<br>Экземпляр класса, переменная со своей собственной копией полей - Объект<br>Инструмент для создания новых объектов на основе класса - Конструктор<br><br> |


```java
public class Practicum {
    public static void main(String[] args) {
        Hamster bite = new Hamster(); // вызывается конструктор по умолчанию
        System.out.println("Имя хомяка по умолчанию: " + bite.name); // у всех объектов по умолчанию поле name имеет значение "Байт"
    }
}
```

```output
Имя хомяка по умолчанию: Байт
```

### Объявление конструктора
_Пустой конструктор_
```java
public class Hamster {
    // поля
    String name = "Байт"; // имя
    int age = 2; // возраст
    String color = "Рыжий"; // цвет
    int weight = 350;

    /* Пустой конструктор. Java создаёт такой автоматически, 
    если в классе не указано ни одного конструктора. */
    Hamster() {
    }
} 
```

```java
public class Hamster {
    // объявили поля, но не присвоили им значения
    String name;  // имя
    int age;      // возраст
    int weight;   // вес в граммах
    String color; // цвет
    
    // конструктор принимает четыре параметра
    Hamster(String hamsterName, int hamsterAge, int hamsterWeight, String hamsterColor) {
        name = hamsterName;
        age = hamsterAge;
        weight = hamsterWeight;
        color = hamsterColor;
    }
}
```


| ==Summary== | Объект — набор полей и методов, которые сгруппированы вместе для представления какой-либо сущности.<br><br>Класс — шаблон для создания объекта. Он описывает в коде сам объект, его свойства (поля) и методы.<br><br>Класс создают так: нужно указать служебное слово (например, `public`) и слово `class`, а затем дать классу имя и поставить фигурные скобки. Например:   `public class Hamster {}`<br>  <br>Внутри фигурных скобок нужно объявить поля (свойства объекта) и методы (функции) — это тело класса.<br><br>Cоздать объект можно с помощью слова `new`, имени класса и пары круглых скобок. Например: `Hamster bite = new Hamster()`.<br><br>Взаимодействие с новым объектом происходит через его методы — используется точка после имени переменной, в которой хранится объект. Например: `bite.runInWheel()`.<br><br>Обращение к полям объекта также происходит с помощью точечной нотации. Например: `bite.weight`.<br><br>У разных объектов, которые созданы на базе одного класса, одинаковая структура — набор полей и методов. При этом значения полей одного объекта не зависят от значений полей другого объекта.<br><br>Конструктор создаёт новые объекты класса. Например, конструктор по умолчанию `Hamster bite = new Hamster()` позволяет создавать объекты с заранее заданными значениями полей.<br><br>Чтобы создавать объекты с разными значениями полей, используют конструкторы с параметрами. Их объявляют внутри класса.<br><br>Рефакторинг — процесс изменения структуры программы. В ходе рефакторинга в код могут в том числе добавляться новые классы. Когда у программы есть классы, с ней проще работать. Каждый из таких классов можно дополнять и дорабатывать отдельно. Кроме того, не нужно читать и анализировать один большой блок кода. |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

## Конспект

| Тема                                  | Описание                                                                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Приведение типов                      |                                                                                                                                                                                                                                                                                                                                                                                                        |
| Сложные типы данных. Классы - обертки | Методы-обертки могут переводить числа в другие типы (например, из строки в int или float). Пример: `parseInt(<Значение>)` <br><br>У методов `Integer` `Long` `Float` `Double` можно находить максимальное и минимальное значение из двух вариантов<br><br>Для приведения классов-оберток к примитивам также можно использовать методы :<br>`[имя примитива, к которому нужно привести]value()`<br><br> |
``` java
Long bigNumber = 10L;
short smallNumber = bigNumber.shortValue();
```

| Тема | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| ---- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Стек | Структура данных, при которой последний добавленный элемент будет доступен первым при обращении. Стек отличается высокой эффективностью, так как обратить к данным из памяти можно ща минимальное время. Размер стека небольшой и обычно не превышает 512 килобайт. Когда метод начинает выполняться для него создается новый блок - Фрейм стека (stack frame, "Стековый кадр"). Все переменные, которые используются в методе будут созданы внутри этого блока. Когда метод завершится, его блок завершить и данные удалятся из стека. **Поэтому все переменные, которые созданы внутри метода, становятся недоступными** . <br><br>Если в метод нужно передать аргументы, значения этих аргументов копируются в блок стека.                           |
| Куча | Для хранения объектов используется куча (heap), так как они большие по объему и в стек не поместятся. В отличии от стека это динамическая область памяти. Она не имеет ограничений по объему. Но за это расплачивается скоростью - системе требуется больше времени на чтение и запись.  <br><br>Когда мы создаем объект в стеке создается только ссылка с информацией, где в куче находятся данные для этой переменной. Массив это тоже тип данных, значения которого хранятся в куче. <br><br>Когда мы передаем в метод объект, то в переменную копируется ссылка на этот объект. Если внутри объекта мы что-то сделаем с ним, то после выхода из метода, изменения останутся. То есть изменения будут везде, где используется ссылка на этот объект. |

---